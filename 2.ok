import imaplib
import email
from email.header import decode_header
import os
from dotenv import load_dotenv
import html
import re
import google.generativeai as genai
from telegram import Bot
from telegram.error import TelegramError
import time
import traceback
import logging
from telegram.helpers import escape_markdown
import asyncio
import tenacity
import html2text
from urllib.parse import urlparse

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='emil.log',
    filemode='w'
)

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# é…ç½®å¸¸é‡
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD")
IMAP_SERVER = os.getenv("IMAP_SERVER")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_API_KEY")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
TELEGRAM_MAX_LENGTH = 3500

# åˆå§‹åŒ– AI å’Œ Bot
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')
bot = Bot(token=TELEGRAM_BOT_TOKEN)

# åˆå§‹åŒ–html2textè½¬æ¢å™¨
html_converter = html2text.HTML2Text()
html_converter.ignore_links = False
html_converter.ignore_images = True
html_converter.body_width = 0
html_converter.protect_links = True  # ä¿æŠ¤å·²æœ‰é“¾æ¥æ ¼å¼

def enhance_urls(text):
    """
    ä¸“ä¸šURLå¤„ç†ï¼š
    1. ä¿æŠ¤ç°æœ‰çš„Markdownè¶…é“¾æ¥
    2. å°†è£¸URLè½¬æ¢ä¸ºä¸“ä¸šè¶…é“¾æ¥æ ¼å¼
    3. æ™ºèƒ½ç”Ÿæˆé“¾æ¥æè¿°æ–‡æœ¬
    """
    # ä¿æŠ¤ç°æœ‰è¶…é“¾æ¥
    protected_links = set(re.findall(r'$$.*?$$$https?://.*?$', text))
    protected_text = text
    
    # å¤„ç†è£¸URL
    url_pattern = re.compile(
        r'(?<!\]$)https?://(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(?:/[^\s]*)?'
    )
    
    def url_replacer(match):
        url = match.group(0)
        if any(url in link for link in protected_links):
            return url
            
        parsed = urlparse(url)
        domain = parsed.netloc.replace('www.', '')
        
        # æŸ¥æ‰¾å‰æ–‡ä¸­çš„åˆé€‚æè¿°
        preceding_text = text[:match.start()].strip()
        if preceding_text:
            # æå–æœ€åä¸€ä¸ªæœ‰æ„ä¹‰çš„çŸ­è¯­
            descriptor = re.split(r'[.!?]\s+|\n', preceding_text)[-1]
            descriptor = re.sub(r'^\W+', '', descriptor)
            if 3 < len(descriptor) < 30 and not descriptor.lower().startswith('http'):
                return f"[{descriptor}]({url})"
        
        # é»˜è®¤ä½¿ç”¨æ™ºèƒ½æè¿°
        path = parsed.path.strip('/')
        if path and len(path) < 20:
            return f"[{domain}/{path}]({url})"
        return f"[{domain}]({url})"
    
    return url_pattern.sub(url_replacer, protected_text)

def extract_email_body(msg):
    """ä¸“ä¸šé‚®ä»¶æ­£æ–‡æå–"""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                body = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'), 
                    'ignore'
                )
                return enhance_urls(body)
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'),
                    'ignore'
                )
                markdown_text = html_converter.handle(html_content)
                return enhance_urls(markdown_text)
    body = msg.get_payload(decode=True).decode('utf-8', 'ignore')
    return enhance_urls(body)

async def test_telegram_connection():
    """æµ‹è¯• Telegram è¿æ¥"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text="âœ… æœºå™¨äººè¿æ¥æµ‹è¯•æˆåŠŸï¼"
        )
        logging.info("Telegram è¿æ¥æµ‹è¯•æˆåŠŸ")
        return True
    except Exception as e:
        logging.error(f"Telegram è¿æ¥æµ‹è¯•å¤±è´¥: {str(e)}")
        return False

def decode_email_header(header):
    """è§£ç é‚®ä»¶å¤´"""
    try:
        return ''.join([
            part.decode(encoding or 'utf-8', 'ignore') if isinstance(part, bytes) 
            else str(part)
            for part, encoding in decode_header(header)
        ])
    except Exception as e:
        logging.error(f"å¤´è§£ç å¤±è´¥: {str(e)}")
        return str(header)

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=2, max=10)
)
async def translate_to_chinese(text):
    """ä¸“ä¸šçº§AIç¿»è¯‘å¤„ç†å™¨"""
    try:
        prompt = (
            "ä½œä¸ºä¸“ä¸šç¿»è¯‘å¼•æ“ï¼Œè¯·å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘ä¸ºå‡†ç¡®ã€æµç•…çš„ä¸­æ–‡ï¼š\n"
            "1. ä¸¥æ ¼ä¿ç•™æ‰€æœ‰æŠ€æœ¯æœ¯è¯­ã€ä¸“æœ‰åè¯å’Œå“ç‰Œåç§°çš„åŸè²Œ\n"
            "2. ä¿æŒMarkdownè¶…é“¾æ¥æ ¼å¼ä¸å˜ï¼š[æè¿°](URL)\n"
            "3. å¯¹é‡‘è/ç§‘æŠ€ç±»å†…å®¹ä¿æŒæ•°å­—å’Œå•ä½çš„ç²¾ç¡®æ€§\n"
            "4. é‡‡ç”¨æ­£å¼ä¹¦é¢è¯­ä½“ï¼Œé¿å…å£è¯­åŒ–è¡¨è¾¾\n"
            "5. å¯¹æ–‡åŒ–ç‰¹å®šå†…å®¹æ·»åŠ å¿…è¦æ³¨é‡Š[æ³¨]\n\n"
            f"å¾…ç¿»è¯‘å†…å®¹ï¼š\n{text[:15000]}"  # å®‰å…¨é•¿åº¦é™åˆ¶
        )
        
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: model.generate_content(prompt)
        )
        return response.text if response else "ç¿»è¯‘æœåŠ¡æš‚ä¸å¯ç”¨"
    except Exception as e:
        logging.error(f"AIç¿»è¯‘å¼‚å¸¸: {str(e)}")
        return None

async def safe_send_message(text, parse_mode):
    """å®‰å…¨å‘é€æ¶ˆæ¯çš„æ ¸å¿ƒå‡½æ•°"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=text,
            parse_mode=parse_mode,
            disable_web_page_preview=True
        )
        return True
    except TelegramError as e:
        logging.error(f"Telegram é”™è¯¯ ({parse_mode}): {str(e)}")
        return False

async def send_telegram_message(message):
    """æ™ºèƒ½æ¶ˆæ¯å‘é€å¤„ç†å™¨"""
    if await safe_send_message(message[:TELEGRAM_MAX_LENGTH], "MarkdownV2"):
        for i in range(1, len(message) // TELEGRAM_MAX_LENGTH + 1):
            await safe_send_message(
                message[i*TELEGRAM_MAX_LENGTH:(i+1)*TELEGRAM_MAX_LENGTH],
                "MarkdownV2"
            )
        return
    
    logging.info("å°è¯•çº¯æ–‡æœ¬æ¨¡å¼...")
    plain_text = re.sub(r'$$(.*?)$$\((.*?)$', r'\1: \2', message)
    if await safe_send_message(plain_text[:3500], None):
        for i in range(1, len(plain_text) // 3500 + 1):
            await safe_send_message(plain_text[i*3500:(i+1)*3500], None)

async def process_email(email_msg):
    """ä¸“ä¸šé‚®ä»¶å¤„ç†æµç¨‹"""
    try:
        from_ = decode_email_header(email_msg.get("From", ""))
        subject = decode_email_header(email_msg.get("Subject", ""))
        date = decode_email_header(email_msg.get("Date", ""))
        
        raw_body = extract_email_body(email_msg) or "æ— æ³•æå–æ­£æ–‡å†…å®¹"
        translated = await translate_to_chinese(raw_body[:3500]) or f"âš ï¸ ç¿»è¯‘å¤±è´¥\nåŸå§‹å†…å®¹ï¼š\n{raw_body[:3500]}"

        message = (
            f"ğŸ“¬ *ä¸“ä¸šé‚®ä»¶æ‘˜è¦*\n"
            f"â–Œå‘ä»¶äººï¼š`{escape_markdown(from_, version=2)}`\n"
            f"â–Œä¸»é¢˜ï¼š_{escape_markdown(subject, version=2)}_\n"
            f"â–Œæ—¶é—´ï¼š`{escape_markdown(date, version=2)}`\n\n"
            f"{translated}"
        )

        await send_telegram_message(message)
        
    except Exception as e:
        logging.error(f"é‚®ä»¶å¤„ç†å¼‚å¸¸: {str(e)}")
        await send_telegram_message("âš ï¸ ä¸“ä¸šé‚®ä»¶å¤„ç†æµç¨‹å‡ºé”™")

async def email_fetcher():
    """ä¸“ä¸šé‚®ä»¶è·å–å¼•æ“"""
    try:
        with imaplib.IMAP4_SSL(IMAP_SERVER) as mail:
            mail.login(EMAIL_USER, EMAIL_PASSWORD)
            mail.select("inbox")
            
            status, [msg_ids] = mail.search(None, "UNSEEN")
            if status != "OK" or not msg_ids:
                return

            for num in msg_ids.split():
                status, data = mail.fetch(num, "(RFC822)")
                if status == "OK":
                    await process_email(email.message_from_bytes(data[0][1]))
                    mail.store(num, "+FLAGS", "\\Seen")

    except Exception as e:
        logging.error(f"IMAPæœåŠ¡å™¨å¼‚å¸¸: {str(e)}")

async def main():
    """ä¸“ä¸šæ‰§è¡Œå…¥å£"""
    if not await test_telegram_connection():
        return
    
    start_time = time.time()
    try:
        await email_fetcher()
        await send_telegram_message(f"âœ… ä¸“ä¸šé‚®ä»¶å¤„ç†å®Œæˆ (è€—æ—¶: {time.time() - start_time:.2f}ç§’)")
    except Exception as e:
        await send_telegram_message(f"âŒ ä¸“ä¸šæµç¨‹æ‰§è¡Œå¤±è´¥: {escape_markdown(str(e), version=2)}")
        raise

if __name__ == "__main__":
    asyncio.run(main())