import imaplib
import email
from email.header import decode_header
import os
from dotenv import load_dotenv
import html
import re
import google.generativeai as genai
from telegram import Bot
from telegram.error import TelegramError
import time
import traceback
import logging
from telegram.helpers import escape_markdown
import asyncio
import tenacity
import html2text
from urllib.parse import urlparse

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='emil.log',
    filemode='w'
)

# 加载环境变量
load_dotenv()

# 配置常量
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD")
IMAP_SERVER = os.getenv("IMAP_SERVER")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_API_KEY")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
TELEGRAM_MAX_LENGTH = 3500

# 初始化 AI 和 Bot
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')
bot = Bot(token=TELEGRAM_BOT_TOKEN)

# 初始化html2text转换器
html_converter = html2text.HTML2Text()
html_converter.ignore_links = False
html_converter.ignore_images = True
html_converter.body_width = 0
html_converter.protect_links = True  # 保护已有链接格式

def enhance_urls(text):
    """
    专业URL处理：
    1. 保护现有的Markdown超链接
    2. 将裸URL转换为专业超链接格式
    3. 智能生成链接描述文本
    """
    # 保护现有超链接
    protected_links = set(re.findall(r'$$.*?$$$https?://.*?$', text))
    protected_text = text
    
    # 处理裸URL
    url_pattern = re.compile(
        r'(?<!\]$)https?://(?:[a-zA-Z0-9-]+\.)+[a-zA-Z]{2,}(?:/[^\s]*)?'
    )
    
    def url_replacer(match):
        url = match.group(0)
        if any(url in link for link in protected_links):
            return url
            
        parsed = urlparse(url)
        domain = parsed.netloc.replace('www.', '')
        
        # 查找前文中的合适描述
        preceding_text = text[:match.start()].strip()
        if preceding_text:
            # 提取最后一个有意义的短语
            descriptor = re.split(r'[.!?]\s+|\n', preceding_text)[-1]
            descriptor = re.sub(r'^\W+', '', descriptor)
            if 3 < len(descriptor) < 30 and not descriptor.lower().startswith('http'):
                return f"[{descriptor}]({url})"
        
        # 默认使用智能描述
        path = parsed.path.strip('/')
        if path and len(path) < 20:
            return f"[{domain}/{path}]({url})"
        return f"[{domain}]({url})"
    
    return url_pattern.sub(url_replacer, protected_text)

def extract_email_body(msg):
    """专业邮件正文提取"""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                body = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'), 
                    'ignore'
                )
                return enhance_urls(body)
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'),
                    'ignore'
                )
                markdown_text = html_converter.handle(html_content)
                return enhance_urls(markdown_text)
    body = msg.get_payload(decode=True).decode('utf-8', 'ignore')
    return enhance_urls(body)

async def test_telegram_connection():
    """测试 Telegram 连接"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text="✅ 机器人连接测试成功！"
        )
        logging.info("Telegram 连接测试成功")
        return True
    except Exception as e:
        logging.error(f"Telegram 连接测试失败: {str(e)}")
        return False

def decode_email_header(header):
    """解码邮件头"""
    try:
        return ''.join([
            part.decode(encoding or 'utf-8', 'ignore') if isinstance(part, bytes) 
            else str(part)
            for part, encoding in decode_header(header)
        ])
    except Exception as e:
        logging.error(f"头解码失败: {str(e)}")
        return str(header)

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=2, max=10)
)
async def translate_to_chinese(text):
    """专业级AI翻译处理器"""
    try:
        prompt = (
            "作为专业翻译引擎，请将以下内容翻译为准确、流畅的中文：\n"
            "1. 严格保留所有技术术语、专有名词和品牌名称的原貌\n"
            "2. 保持Markdown超链接格式不变：[描述](URL)\n"
            "3. 对金融/科技类内容保持数字和单位的精确性\n"
            "4. 采用正式书面语体，避免口语化表达\n"
            "5. 对文化特定内容添加必要注释[注]\n\n"
            f"待翻译内容：\n{text[:15000]}"  # 安全长度限制
        )
        
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: model.generate_content(prompt)
        )
        return response.text if response else "翻译服务暂不可用"
    except Exception as e:
        logging.error(f"AI翻译异常: {str(e)}")
        return None

async def safe_send_message(text, parse_mode):
    """安全发送消息的核心函数"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=text,
            parse_mode=parse_mode,
            disable_web_page_preview=True
        )
        return True
    except TelegramError as e:
        logging.error(f"Telegram 错误 ({parse_mode}): {str(e)}")
        return False

async def send_telegram_message(message):
    """智能消息发送处理器"""
    if await safe_send_message(message[:TELEGRAM_MAX_LENGTH], "MarkdownV2"):
        for i in range(1, len(message) // TELEGRAM_MAX_LENGTH + 1):
            await safe_send_message(
                message[i*TELEGRAM_MAX_LENGTH:(i+1)*TELEGRAM_MAX_LENGTH],
                "MarkdownV2"
            )
        return
    
    logging.info("尝试纯文本模式...")
    plain_text = re.sub(r'$$(.*?)$$\((.*?)$', r'\1: \2', message)
    if await safe_send_message(plain_text[:3500], None):
        for i in range(1, len(plain_text) // 3500 + 1):
            await safe_send_message(plain_text[i*3500:(i+1)*3500], None)

async def process_email(email_msg):
    """专业邮件处理流程"""
    try:
        from_ = decode_email_header(email_msg.get("From", ""))
        subject = decode_email_header(email_msg.get("Subject", ""))
        date = decode_email_header(email_msg.get("Date", ""))
        
        raw_body = extract_email_body(email_msg) or "无法提取正文内容"
        translated = await translate_to_chinese(raw_body[:3500]) or f"⚠️ 翻译失败\n原始内容：\n{raw_body[:3500]}"

        message = (
            f"📬 *专业邮件摘要*\n"
            f"▌发件人：`{escape_markdown(from_, version=2)}`\n"
            f"▌主题：_{escape_markdown(subject, version=2)}_\n"
            f"▌时间：`{escape_markdown(date, version=2)}`\n\n"
            f"{translated}"
        )

        await send_telegram_message(message)
        
    except Exception as e:
        logging.error(f"邮件处理异常: {str(e)}")
        await send_telegram_message("⚠️ 专业邮件处理流程出错")

async def email_fetcher():
    """专业邮件获取引擎"""
    try:
        with imaplib.IMAP4_SSL(IMAP_SERVER) as mail:
            mail.login(EMAIL_USER, EMAIL_PASSWORD)
            mail.select("inbox")
            
            status, [msg_ids] = mail.search(None, "UNSEEN")
            if status != "OK" or not msg_ids:
                return

            for num in msg_ids.split():
                status, data = mail.fetch(num, "(RFC822)")
                if status == "OK":
                    await process_email(email.message_from_bytes(data[0][1]))
                    mail.store(num, "+FLAGS", "\\Seen")

    except Exception as e:
        logging.error(f"IMAP服务器异常: {str(e)}")

async def main():
    """专业执行入口"""
    if not await test_telegram_connection():
        return
    
    start_time = time.time()
    try:
        await email_fetcher()
        await send_telegram_message(f"✅ 专业邮件处理完成 (耗时: {time.time() - start_time:.2f}秒)")
    except Exception as e:
        await send_telegram_message(f"❌ 专业流程执行失败: {escape_markdown(str(e), version=2)}")
        raise

if __name__ == "__main__":
    asyncio.run(main())