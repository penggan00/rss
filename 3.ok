import imaplib
import email
from email.header import decode_header
import os
from dotenv import load_dotenv
import re
import google.generativeai as genai
from telegram import Bot
from telegram.error import TelegramError
import time
import traceback
import logging
from md2tgmd import escape
import asyncio
import tenacity
from urllib.parse import urlparse
from bs4 import BeautifulSoup

# 配置日志
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='email_to_telegram.log',
    filemode='w'
)

# 加载环境变量
load_dotenv()

# 配置常量
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD")
IMAP_SERVER = os.getenv("IMAP_SERVER")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_API_KEY")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
TELEGRAM_MAX_LENGTH = 3500

# 初始化 AI 和 Bot
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')
bot = Bot(token=TELEGRAM_BOT_TOKEN)

async def test_telegram_connection():
    """测试 Telegram 连接"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text="✅ 机器人连接测试成功！"
        )
        logging.info("Telegram 连接测试成功")
        return True
    except Exception as e:
        logging.error(f"Telegram 连接测试失败: {str(e)}")
        return False

def decode_email_header(header):
    """解码邮件头"""
    try:
        return ''.join([
            part.decode(encoding or 'utf-8', 'ignore') if isinstance(part, bytes) 
            else str(part)
            for part, encoding in decode_header(header)
        ])
    except Exception as e:
        logging.error(f"头解码失败: {str(e)}")
        return str(header)

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=2, max=10)
)
async def translate_to_chinese(text):
    """同步转异步的Gemini调用"""
    try:
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: model.generate_content(
                f"将以下内容翻译为中文。如果内容中包含URL，请将其转换为MarkdownV2格式的超链接，只保留超链接，不要重复显示原始URL文本。保留专业术语，确保符合电报机器人markdownv2格式，不要转义：\n{text}"
            )
        )
        return response.text if response else "翻译无返回"
    except Exception as e:
        logging.error(f"Gemini翻译异常: {str(e)}")
        return None

async def safe_send_message(text, parse_mode):
    """安全发送消息的核心函数"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=text,
            parse_mode=parse_mode,
            disable_web_page_preview=True
        )
        return True
    except TelegramError as e:
        logging.error(f"Telegram 错误 ({parse_mode}): {str(e)}")
        return False

async def send_telegram_message(message):
    """智能消息发送处理器"""
    # 优先尝试 MarkdownV2
    if await safe_send_message(message[:TELEGRAM_MAX_LENGTH], "MarkdownV2"):
        for i in range(1, len(message) // TELEGRAM_MAX_LENGTH + 1):
            await safe_send_message(
                message[i*TELEGRAM_MAX_LENGTH:(i+1)*TELEGRAM_MAX_LENGTH],
                "MarkdownV2"
            )
        return
    
    # Markdown 失败后尝试纯文本
    logging.info("尝试纯文本模式...")
    plain_text = re.sub(r'$$(.*?)$$$(.*?)$', r'\1: \2', message)
    if await safe_send_message(plain_text[:3500], None):
        for i in range(1, len(plain_text) // 3500 + 1):
            await safe_send_message(plain_text[i*3500:(i+1)*3500], None)

def extract_email_body(msg):
    """多层级解析邮件正文"""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                return part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'), 
                    'ignore'
                )
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'),
                    'ignore'
                )
                return html.unescape(re.sub('<[^<]+?>', ' ', html_content))
    return msg.get_payload(decode=True).decode('utf-8', 'ignore')

async def process_email(email_msg):
    """带降级机制的邮件处理器"""
    try:
        # 基础信息提取
        from_ = decode_email_header(email_msg.get("From", ""))
        subject = decode_email_header(email_msg.get("Subject", ""))
        date = decode_email_header(email_msg.get("Date", ""))
        
        # 正文提取（带降级）
        raw_body = extract_email_body(email_msg)
        if not raw_body:
            raw_body = "无法提取正文内容"

        # 翻译尝试（带降级）
        translated = await translate_to_chinese(raw_body[:3500])  # 限制长度
        if not translated:
            translated = f"⚠️ 翻译失败，原始内容：\n{raw_body[:3500]}"

        # 消息构造（自动转义）
        message = (
            f"📬 *新邮件*\n"
            f"• 发件人: `{escape(from_)}`\n"
            f"• 主题: _{escape(subject)}_ \n"
            f"• 时间: `{escape(date)}`\n\n"
            f"{translated}"
        )

        await send_telegram_message(message)
        
    except Exception as e:
        logging.error(f"邮件处理崩溃: {str(e)}")
        await send_telegram_message("⚠️ 邮件处理出错，请检查日志")

async def email_fetcher():
    """邮件获取主循环"""
    try:
        # 连接邮箱
        with imaplib.IMAP4_SSL(IMAP_SERVER) as mail:
            mail.login(EMAIL_USER, EMAIL_PASSWORD)
            mail.select("inbox")
            
            # 搜索未读邮件
            status, [msg_ids] = mail.search(None, "UNSEEN")
            if status != "OK" or not msg_ids:
                return

            for num in msg_ids.split():
                status, data = mail.fetch(num, "(RFC822)")
                if status == "OK":
                    await process_email(email.message_from_bytes(data[0][1]))
                    mail.store(num, "+FLAGS", "\\Seen")

    except Exception as e:
        logging.error(f"邮件服务器错误: {str(e)}")

async def main():
    """主函数（单次执行，适合cron调用）"""
    if not await test_telegram_connection():
        return
    
    start_time = time.time()
    try:
        await email_fetcher()
        await send_telegram_message(f"✅ 邮件检查完成 (耗时: {time.time() - start_time:.2f}秒)")
    except Exception as e:
        await send_telegram_message(f"❌ 邮件检查失败: {escape(str(e))}")
        raise  # 确保cron能捕获错误

if __name__ == "__main__":
    asyncio.run(main())
