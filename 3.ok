import imaplib
import email
from email.header import decode_header
import os
from dotenv import load_dotenv
import re
import google.generativeai as genai
from telegram import Bot
from telegram.error import TelegramError
import time
import traceback
import logging
from md2tgmd import escape
import asyncio
import tenacity
from urllib.parse import urlparse
from bs4 import BeautifulSoup

# é…ç½®æ—¥å¿—
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename='email_to_telegram.log',
    filemode='w'
)

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# é…ç½®å¸¸é‡
EMAIL_USER = os.getenv("EMAIL_USER")
EMAIL_PASSWORD = os.getenv("EMAIL_PASSWORD")
IMAP_SERVER = os.getenv("IMAP_SERVER")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_API_KEY")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
TELEGRAM_MAX_LENGTH = 3500

# åˆå§‹åŒ– AI å’Œ Bot
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel('gemini-2.0-flash-exp')
bot = Bot(token=TELEGRAM_BOT_TOKEN)

async def test_telegram_connection():
    """æµ‹è¯• Telegram è¿æ¥"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text="âœ… æœºå™¨äººè¿æ¥æµ‹è¯•æˆåŠŸï¼"
        )
        logging.info("Telegram è¿æ¥æµ‹è¯•æˆåŠŸ")
        return True
    except Exception as e:
        logging.error(f"Telegram è¿æ¥æµ‹è¯•å¤±è´¥: {str(e)}")
        return False

def decode_email_header(header):
    """è§£ç é‚®ä»¶å¤´"""
    try:
        return ''.join([
            part.decode(encoding or 'utf-8', 'ignore') if isinstance(part, bytes) 
            else str(part)
            for part, encoding in decode_header(header)
        ])
    except Exception as e:
        logging.error(f"å¤´è§£ç å¤±è´¥: {str(e)}")
        return str(header)

@tenacity.retry(
    stop=tenacity.stop_after_attempt(3),
    wait=tenacity.wait_exponential(multiplier=1, min=2, max=10)
)
async def translate_to_chinese(text):
    """åŒæ­¥è½¬å¼‚æ­¥çš„Geminiè°ƒç”¨"""
    try:
        loop = asyncio.get_event_loop()
        response = await loop.run_in_executor(
            None,
            lambda: model.generate_content(
                f"å°†ä»¥ä¸‹å†…å®¹ç¿»è¯‘ä¸ºä¸­æ–‡ã€‚å¦‚æœå†…å®¹ä¸­åŒ…å«URLï¼Œè¯·å°†å…¶è½¬æ¢ä¸ºMarkdownV2æ ¼å¼çš„è¶…é“¾æ¥ï¼Œåªä¿ç•™è¶…é“¾æ¥ï¼Œä¸è¦é‡å¤æ˜¾ç¤ºåŸå§‹URLæ–‡æœ¬ã€‚ä¿ç•™ä¸“ä¸šæœ¯è¯­ï¼Œç¡®ä¿ç¬¦åˆç”µæŠ¥æœºå™¨äººmarkdownv2æ ¼å¼ï¼Œä¸è¦è½¬ä¹‰ï¼š\n{text}"
            )
        )
        return response.text if response else "ç¿»è¯‘æ— è¿”å›"
    except Exception as e:
        logging.error(f"Geminiç¿»è¯‘å¼‚å¸¸: {str(e)}")
        return None

async def safe_send_message(text, parse_mode):
    """å®‰å…¨å‘é€æ¶ˆæ¯çš„æ ¸å¿ƒå‡½æ•°"""
    try:
        await bot.send_message(
            chat_id=TELEGRAM_CHAT_ID,
            text=text,
            parse_mode=parse_mode,
            disable_web_page_preview=True
        )
        return True
    except TelegramError as e:
        logging.error(f"Telegram é”™è¯¯ ({parse_mode}): {str(e)}")
        return False

async def send_telegram_message(message):
    """æ™ºèƒ½æ¶ˆæ¯å‘é€å¤„ç†å™¨"""
    # ä¼˜å…ˆå°è¯• MarkdownV2
    if await safe_send_message(message[:TELEGRAM_MAX_LENGTH], "MarkdownV2"):
        for i in range(1, len(message) // TELEGRAM_MAX_LENGTH + 1):
            await safe_send_message(
                message[i*TELEGRAM_MAX_LENGTH:(i+1)*TELEGRAM_MAX_LENGTH],
                "MarkdownV2"
            )
        return
    
    # Markdown å¤±è´¥åå°è¯•çº¯æ–‡æœ¬
    logging.info("å°è¯•çº¯æ–‡æœ¬æ¨¡å¼...")
    plain_text = re.sub(r'$$(.*?)$$$(.*?)$', r'\1: \2', message)
    if await safe_send_message(plain_text[:3500], None):
        for i in range(1, len(plain_text) // 3500 + 1):
            await safe_send_message(plain_text[i*3500:(i+1)*3500], None)

def extract_email_body(msg):
    """å¤šå±‚çº§è§£æé‚®ä»¶æ­£æ–‡"""
    if msg.is_multipart():
        for part in msg.walk():
            content_type = part.get_content_type()
            if content_type == "text/plain":
                return part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'), 
                    'ignore'
                )
            elif content_type == "text/html":
                html_content = part.get_payload(decode=True).decode(
                    part.get_content_charset('utf-8'),
                    'ignore'
                )
                return html.unescape(re.sub('<[^<]+?>', ' ', html_content))
    return msg.get_payload(decode=True).decode('utf-8', 'ignore')

async def process_email(email_msg):
    """å¸¦é™çº§æœºåˆ¶çš„é‚®ä»¶å¤„ç†å™¨"""
    try:
        # åŸºç¡€ä¿¡æ¯æå–
        from_ = decode_email_header(email_msg.get("From", ""))
        subject = decode_email_header(email_msg.get("Subject", ""))
        date = decode_email_header(email_msg.get("Date", ""))
        
        # æ­£æ–‡æå–ï¼ˆå¸¦é™çº§ï¼‰
        raw_body = extract_email_body(email_msg)
        if not raw_body:
            raw_body = "æ— æ³•æå–æ­£æ–‡å†…å®¹"

        # ç¿»è¯‘å°è¯•ï¼ˆå¸¦é™çº§ï¼‰
        translated = await translate_to_chinese(raw_body[:3500])  # é™åˆ¶é•¿åº¦
        if not translated:
            translated = f"âš ï¸ ç¿»è¯‘å¤±è´¥ï¼ŒåŸå§‹å†…å®¹ï¼š\n{raw_body[:3500]}"

        # æ¶ˆæ¯æ„é€ ï¼ˆè‡ªåŠ¨è½¬ä¹‰ï¼‰
        message = (
            f"ğŸ“¬ *æ–°é‚®ä»¶*\n"
            f"â€¢ å‘ä»¶äºº: `{escape(from_)}`\n"
            f"â€¢ ä¸»é¢˜: _{escape(subject)}_ \n"
            f"â€¢ æ—¶é—´: `{escape(date)}`\n\n"
            f"{translated}"
        )

        await send_telegram_message(message)
        
    except Exception as e:
        logging.error(f"é‚®ä»¶å¤„ç†å´©æºƒ: {str(e)}")
        await send_telegram_message("âš ï¸ é‚®ä»¶å¤„ç†å‡ºé”™ï¼Œè¯·æ£€æŸ¥æ—¥å¿—")

async def email_fetcher():
    """é‚®ä»¶è·å–ä¸»å¾ªç¯"""
    try:
        # è¿æ¥é‚®ç®±
        with imaplib.IMAP4_SSL(IMAP_SERVER) as mail:
            mail.login(EMAIL_USER, EMAIL_PASSWORD)
            mail.select("inbox")
            
            # æœç´¢æœªè¯»é‚®ä»¶
            status, [msg_ids] = mail.search(None, "UNSEEN")
            if status != "OK" or not msg_ids:
                return

            for num in msg_ids.split():
                status, data = mail.fetch(num, "(RFC822)")
                if status == "OK":
                    await process_email(email.message_from_bytes(data[0][1]))
                    mail.store(num, "+FLAGS", "\\Seen")

    except Exception as e:
        logging.error(f"é‚®ä»¶æœåŠ¡å™¨é”™è¯¯: {str(e)}")

async def main():
    """ä¸»å‡½æ•°ï¼ˆå•æ¬¡æ‰§è¡Œï¼Œé€‚åˆcronè°ƒç”¨ï¼‰"""
    if not await test_telegram_connection():
        return
    
    start_time = time.time()
    try:
        await email_fetcher()
        await send_telegram_message(f"âœ… é‚®ä»¶æ£€æŸ¥å®Œæˆ (è€—æ—¶: {time.time() - start_time:.2f}ç§’)")
    except Exception as e:
        await send_telegram_message(f"âŒ é‚®ä»¶æ£€æŸ¥å¤±è´¥: {escape(str(e))}")
        raise  # ç¡®ä¿cronèƒ½æ•è·é”™è¯¯

if __name__ == "__main__":
    asyncio.run(main())
